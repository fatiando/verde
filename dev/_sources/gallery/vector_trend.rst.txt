

.. _sphx_glr_gallery_vector_trend.py:


Trends in vector data
=====================

Verde provides the :class:`verde.VectorTrend` class to estimate a polynomial
trend on each component of vector data, like GPS velocities. You can access
each trend as a separate :class:`verde.Trend` or operate on all vector
components directly using using :meth:`verde.VectorTrend.predict`,
:meth:`verde.VectorTrend.grid`, etc, or chaining it with a vector interpolator
using :class:`verde.Chain`.




.. image:: /gallery/images/sphx_glr_vector_trend_001.png
    :align: center


.. rst-class:: sphx-glr-script-out

 Out::

    Vector trend estimator: VectorTrend(degree=4)
    East component trend: Trend(degree=4)
    East trend coefficients: [-1.55529375e+05  2.46266603e+03  7.22242703e+02 -1.45235549e+01
     -9.89215728e+00  3.08265561e+00  3.78051065e-02  4.40629237e-02
     -2.05842672e-02 -1.13631834e-02 -3.66372645e-05 -6.42605093e-05
      3.39395783e-05  3.95095228e-05  1.33893042e-05]
    North component trend: Trend(degree=4)
    North trend coefficients: [ 3.20218511e+05 -4.98176868e+03 -2.00541617e+03  2.89493187e+01
      2.48984300e+01 -2.10352487e-01 -7.44873472e-02 -1.01898444e-01
     -6.07188259e-03  1.76506616e-02  7.16162045e-05  1.37648401e-04
      2.62731076e-05 -6.18009148e-05 -1.91162474e-05]

    Gridded 2-component trend:
    <xarray.Dataset>
    Dimensions:          (latitude: 97, longitude: 94)
    Coordinates:
      * longitude        (longitude) float64 235.7 235.8 235.9 236.0 236.1 236.2 ...
      * latitude         (latitude) float64 32.29 32.39 32.49 32.59 32.69 32.79 ...
    Data variables:
        east_component   (latitude, longitude) float64 -0.1883 -0.182 -0.1759 ...
        north_component  (latitude, longitude) float64 0.3852 0.3689 0.3532 ...
    Attributes:
        metadata:  Generated by VectorTrend(degree=4)




|


.. code-block:: python

    import matplotlib.pyplot as plt
    import cartopy.crs as ccrs
    import cartopy.feature as cfeature
    # We need these two classes to set proper ticklabels for Cartopy maps
    from cartopy.mpl.ticker import LongitudeFormatter, LatitudeFormatter
    import numpy as np
    import verde as vd


    # Fetch the GPS data from the U.S. West coast. The data has a strong trend
    # toward the North-West because of the relative movement along the San Andreas
    # Fault System.
    data = vd.datasets.fetch_california_gps()

    # We'll fit a degree 4 trend on both the East and North components and weight
    # the data using the inverse of the variance of each component.
    trend = vd.VectorTrend(degree=4)
    weights = vd.variance_to_weights((data.std_east**2, data.std_north**2))
    trend.fit(coordinates=(data.longitude, data.latitude),
              data=(data.velocity_east, data.velocity_north),
              weights=weights)
    print("Vector trend estimator:", trend)

    # The separate Trend objects for each component can be accessed through the
    # 'component_' attribute. You could grid them individually if you wanted.
    print("East component trend:", trend.component_[0])
    print("East trend coefficients:", trend.component_[0].coef_)
    print("North component trend:", trend.component_[1])
    print("North trend coefficients:", trend.component_[1].coef_)

    # We can make a grid with both trend components as data variables
    grid = trend.grid(spacing=0.1, dims=['latitude', 'longitude'])
    print("\nGridded 2-component trend:")
    print(grid)


    # Now we can map both trends along with the original data for comparison
    def plot_trend(ax, component, title):
        "Make a map of the given trend component on the given axes"
        crs = ccrs.PlateCarree()
        ax.set_title(title)
        # Plot the trend in pseudo color
        maxabs = np.abs([component.min(), component.max()]).max()
        tmp = ax.pcolormesh(component.longitude, component.latitude,
                            component.values, vmin=-maxabs, vmax=maxabs,
                            cmap='seismic', transform=crs)
        cb = plt.colorbar(tmp, ax=ax, orientation='horizontal', pad=0.05)
        cb.set_label('meters/year')
        # Plot the original data
        ax.quiver(data.longitude.values, data.latitude.values,
                  data.velocity_east.values, data.velocity_north.values,
                  scale=0.2, transform=crs, color='y', label="Original data")
        # and the residuals
        ax.quiver(data.longitude.values, data.latitude.values,
                  trend.residual_[0].values, trend.residual_[1].values,
                  scale=0.2, transform=crs, color='k', label='Residuals')
        # Setup the map ticks
        ax.set_xticks(np.arange(-124, -115, 4), crs=crs)
        ax.set_yticks(np.arange(33, 42, 2), crs=crs)
        ax.xaxis.set_major_formatter(LongitudeFormatter())
        ax.yaxis.set_major_formatter(LatitudeFormatter())
        ax.coastlines(color='white')
        ax.set_extent(vd.get_region((data.longitude, data.latitude)), crs=crs)


    # Make a plot of the data using Cartopy to handle projections and coastlines
    fig, axes = plt.subplots(1, 2, figsize=(9, 7),
                             subplot_kw=dict(projection=ccrs.Mercator()))
    # Plot the two trend components
    plot_trend(axes[0], grid.east_component, "East component trend")
    plot_trend(axes[1], grid.north_component, "North component trend")
    axes[0].legend(loc="lower left")
    plt.tight_layout()
    plt.show()

**Total running time of the script:** ( 0 minutes  1.106 seconds)



.. container:: sphx-glr-footer


  .. container:: sphx-glr-download

     :download:`Download Python source code: vector_trend.py <vector_trend.py>`



  .. container:: sphx-glr-download

     :download:`Download Jupyter notebook: vector_trend.ipynb <vector_trend.ipynb>`

.. rst-class:: sphx-glr-signature

    `Generated by Sphinx-Gallery <https://sphinx-gallery.readthedocs.io>`_
