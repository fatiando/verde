"""
Base class for all gridders and mix-in classes for different kinds of gridders.
"""
import numpy as np
import xarray as xr
import pandas as pd
from sklearn.base import BaseEstimator

from . import grid_coordinates
from .utils import profile_coordinates


def get_dimensions(instance):
    """
    Get the dimension names from a gridder instance if it has them.
    Otherwise, return default names.

    Examples
    --------

    >>> grd = BaseGridder()
    >>> get_dimensions(grd)
    ('northing', 'easting')
    >>> grd.coordinate_system = 'geographic'
    >>> get_dimensions(grd)
    ('latitude', 'longitude')
    >>> grd.coordinate_system = 'cartesian'
    >>> get_dimensions(grd)
    ('northing', 'easting')

    """
    valid_coords =  ['cartesian', 'geographic']
    coords = getattr(instance, 'coordinate_system', 'cartesian')
    if coords not in valid_coords:
        raise ValueError(
            "Invalid coordinate system for {}: '{}'. Must be one of {}."
            .format(instance.__class__.__name__, coords, str(valid_coords)))
    if coords == 'geographic':
        return ('latitude', 'longitude')
    return ('northing', 'easting')


def check_data(data):
    """
    Check the data returned by predict.
    If the data is a single array, return it as a tuple with a single element.

    Examples
    --------

    >>> check_data([1, 2, 3])
    ([1, 2, 3],)
    >>> check_data(([1, 2], [3, 4]))
    ([1, 2], [3, 4])
    """
    if not isinstance(data, tuple):
        data = (data,)
    return data


class BaseGridder(BaseEstimator):
    """
    Base class for gridders.

    Requires the implementation of the ``predict(easting, northing)`` method.
    The data returned by it should be a 1d or 2d numpy array for scalar data or
    a tuple with 1d or 2d numpy arrays for each component of vector data.

    Doesn't define any new attributes.

    The child class can define the following attributes to control the names of
    coordinates and data values in the output ``xarray.Dataset``s and
    ``pandas.DataFrame``s and how distances are calculated:

    * ``coordinate_system``: either ``'cartesian'`` or ``'geographic'``. Will
      influence dimension names and distance calculations. Defaults to
      ``'cartesian'``.
    * ``data_type``: one of ``'scalar'``, ``'vector2d'``, or ``'vector3d'``.
      Defaults to ``'scalar'``.


    """

    def grid(self, region, shape, dims=None, data_names=None):
        if dims is None:
            dims = get_dimensions(self)
        if data_names is None:
            data_names = get_data_names(self)
        easting, northing = grid_coordinates(region, shape)
        data = check_data(self.predict(easting, northing))
        east_lines = easting[0, :]
        north_lines = northing[:, 0]
        coords = {dims[0]: north_lines, dims[1]:east_lines}
        attrs = {'Generated by': repr(self)}
        data_vars = {}
        for data_array, data_name in zip(data, data_names):
            data_vars[data_name] = (dims, data_array, attrs)
        datagrid = xr.Dataset(data_vars, coords=coords, attrs=attrs)
        return datagrid

    def profile(self, point1, point2, size, dims=None, data_names=None):
        coordinate_system = getattr(self, 'coordinate_system', 'cartesian')
        if dims is None:
            dims = get_dimensions(self)
        if data_names is None:
            data_names = get_data_names(self)
        easting, northing, distances = line_between(point1, point2, size,
                                                    coordinate_system)
        data = check_data(self.predict(easting, northing))
        column_names = [dim for dim in dims]
        column_names.append('distance')
        column_names.extend(data_names)
        columns = [northing, easting, distances]
        columns.extend(data)
        data_dict = {name: value for name, value in zip(column_names, columns)}
        table = pd.DataFrame(data_dict)
        return table
