"""
Base class for all gridders and mix-in classes for different kinds of gridders.
"""
import numpy as np
import xarray as xr
import pandas as pd
from sklearn.base import BaseEstimator

from . import grid_coordinates


def get_dimensions(instance):
    """
    Get the dimension names from a gridder instance if it has them.
    Otherwise, return default names.

    Examples
    --------

    >>> grd = BaseGridder()
    >>> get_dimensions(grd)
    ('northing', 'easting')
    >>> grd.dims = ('john', 'paul')
    >>> get_dimensions(grd)
    ('john', 'paul')

    """
    if hasattr(instance, 'dims'):
        return instance.dims
    return ('northing', 'easting')


def line_between(point1, point1, size):
    east1, north1 = point1
    east2, north2 = point2
    separation = np.sqrt((east1 - east2)**2 + (north1 - north2)**2)
    distances = np.linspace(0, separation, size)
    angle = np.arctan2(north2 - north1, east2 - east1)
    easting = east1 + distances*np.cos(angle)
    northing = north1 + distances*np.sin(angle)
    return easting, northing, distances



class BaseGridder(BaseEstimator):
    """
    Base class for all gridders.

    Defines the common methods for gridding operations.

    Requires the implementation of the ``predict(easting, northing)`` method.
    The data returned by it should be a 1d or 2d numpy array for scalar data or
    a tuple with 1d or 2d numpy arrays for each component of vector data.

    Doesn't define any new attributes.

    Uses ``dims``, ``data_names``, ``coordinate_system`` attributes if they
    exits. Else, uses default values.

    """

    def grid(self, region, shape):
        easting, northing = grid_coordinates(region, shape)
        data = self.predict(easting, northing)
        if not isinstance(data, tuple):
            data = (data,)
        east_lines = easting[0, :]
        north_lines = northing[:, 0]
        coords = {self._dims[0]: north_lines, self._dims[1]:east_lines}
        attrs = {'Generated by': repr(self)}
        data_vars = {}
        for data_array, data_name in zip(data, self._data_names):
            data_vars[data_name] = (self._dims, data_array, attrs)
        datagrid = xr.Dataset(data_vars, coords=coords, attrs=attrs)
        return datagrid

    def profile(self, begin, end, size):
        easting, northing, distances = self.profile_coordinates(begin, end,
                                                                size)
        data = self.predict(easting, northing)
        if not isinstance(data, tuple):
            data = (data,)
        column_names = [dim for dim in self._dims]
        column_names.append('distance')
        column_names.extend(self._data_names)
        columns = [northing, easting, distances]
        columns.extend(data)
        data_dict = {name: value for name, value in zip(column_names, columns)}
        table = pd.DataFrame(data_dict)
        return table
