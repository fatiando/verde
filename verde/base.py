"""
Base class for all gridders and mix-in classes for different kinds of gridders.
"""
import numpy as np
import xarray as xr
import pandas as pd
from sklearn.base import BaseEstimator

from.import grid_coordinates, profile_coordinates


def get_dimensions(instance):
    """
    Get the dimension names from a gridder instance if it has them.
    Otherwise, return default names.

    Examples
    --------

    >>> grd = BaseGridder()
    >>> get_dimensions(grd)
    ('northing', 'easting')
    >>> grd.coordinate_system = 'geographic'
    >>> get_dimensions(grd)
    ('latitude', 'longitude')
    >>> grd.coordinate_system = 'cartesian'
    >>> get_dimensions(grd)
    ('northing', 'easting')

    """
    valid_coords =  ['cartesian', 'geographic']
    coords = getattr(instance, 'coordinate_system', 'cartesian')
    if coords not in valid_coords:
        raise ValueError(
            "Invalid coordinate system for {}: '{}'. Must be one of {}."
            .format(instance.__class__.__name__, coords, str(valid_coords)))
    if coords == 'geographic':
        return ('latitude', 'longitude')
    return ('northing', 'easting')


def check_data(data):
    """
    Check the data returned by predict.
    If the data is a single array, return it as a tuple with a single element.

    Examples
    --------

    >>> check_data([1, 2, 3])
    ([1, 2, 3],)
    >>> check_data(([1, 2], [3, 4]))
    ([1, 2], [3, 4])
    """
    if not isinstance(data, tuple):
        data = (data,)
    return data


class BaseGridder(BaseEstimator):
    """
    Base class for gridders.

    Requires the implementation of the ``predict(easting, northing)`` method.
    The data returned by it should be a 1d or 2d numpy array for scalar data or
    a tuple with 1d or 2d numpy arrays for each component of vector data.

    Doesn't define any new attributes.

    This is a subclass of :class:`sklearn.base.BaseEstimator` and must abide by
    the same rules of the scikit-learn classes. Mainly:

    * ``__init__`` must **only** assign values to attributes based on the
      parameters it receives. All parameters must have default values.
      Parameter checking should be done in ``fit``.
    * Estimated parameters should be stored as attributes with names ending in
      ``_``.

    The child class can define the following attributes to control the names of
    coordinates and data values in the output ``xarray.Dataset``s and
    ``pandas.DataFrame``s and how distances are calculated:

    * ``coordinate_system``: either ``'cartesian'`` or ``'geographic'``. Will
      influence dimension names and distance calculations. Defaults to
      ``'cartesian'``.
    * ``data_type``: one of ``'scalar'``, ``'vector2d'``, or ``'vector3d'``.
      Defaults to ``'scalar'``.

    Examples
    --------

    >>> import numpy as np
    >>> class MeanGridder(BaseGridder):
    ...     "Gridder that always produces the mean of all data values"
    ...     def __init__(self, multiplier=1):
    ...         self.multiplier = 1
    ...     def fit(self, easting, northing, data):
    ...         # Argument checking should be done in fit
    ...         assert self.multiplier > 0
    ...         self.mean_ = data.mean()*self.multiplier
    ...         return self
    ...     def predict(self, easting, northing):
    ...         return np.ones_like(easting)*self.mean_


    """

    def grid(self, region, shape, dims=None, data_names=None):
        """
        """
        if dims is None:
            dims = get_dimensions(self)
        if data_names is None:
            data_names = get_data_names(self)
        easting, northing = grid_coordinates(region, shape)
        data = check_data(self.predict(easting, northing))
        east_lines = easting[0, :]
        north_lines = northing[:, 0]
        coords = {dims[0]: north_lines, dims[1]:east_lines}
        attrs = {'Generated by': repr(self)}
        data_vars = {}
        for data_array, data_name in zip(data, data_names):
            data_vars[data_name] = (dims, data_array, attrs)
        datagrid = xr.Dataset(data_vars, coords=coords, attrs=attrs)
        return datagrid

    def profile(self, point1, point2, size, dims=None, data_names=None):
        """
        """
        coordsys = getattr(self, 'coordinate_system', 'cartesian')
        if dims is None:
            dims = get_dimensions(self)
        if data_names is None:
            data_names = get_data_names(self)
        east, north, distances = profile_coordinates(
            point1, point2, size, coordinate_system=coordsys)
        data = check_data(self.predict(easting, northing))
        column_names = [dim for dim in dims]
        column_names.append('distance')
        column_names.extend(data_names)
        columns = [north, east, distances]
        columns.extend(data)
        data_dict = {name: value for name, value in zip(column_names, columns)}
        table = pd.DataFrame(data_dict)
        return table
