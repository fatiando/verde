"""
Base class for all gridders and mix-in classes for different kinds of gridders.
"""
import numpy as np
import xarray as xr
import pandas as pd
from sklearn.base import BaseEstimator

from.import grid_coordinates, profile_coordinates, scatter_points


def get_dimensions(instance):
    """

    Examples
    --------

    >>> grd = BaseGridder()
    >>> get_dimensions(grd)
    ('northing', 'easting')
    >>> grd.coordinate_system = 'geographic'
    >>> get_dimensions(grd)
    ('latitude', 'longitude')
    >>> grd.coordinate_system = 'cartesian'
    >>> get_dimensions(grd)
    ('northing', 'easting')

    """
    valid_coords =  ['cartesian', 'geographic']
    coords = getattr(instance, 'coordinate_system', 'cartesian')
    if coords not in valid_coords:
        raise ValueError(
            "Invalid coordinate system for {}: '{}'. Must be one of {}."
            .format(instance.__class__.__name__, coords, str(valid_coords)))
    if coords == 'geographic':
        return ('latitude', 'longitude')
    return ('northing', 'easting')


def get_data_names(instance):
    """

    Examples
    --------


    """
    valid_types =  ['scalar', 'vector2d', 'vector3d']
    data_type = getattr(instance, 'data_type', 'scalar')
    if data_type not in valid_types:
        raise ValueError(
            "Invalid data type for {}: '{}'. Must be one of {}."
            .format(instance.__class__.__name__, data_type, str(valid_types)))
    if data_type == 'vector2d':
        return ('east_component', 'north_component')
    elif data_type == 'vector3d':
        return ('east_component', 'north_component', 'vertical_component')
    return ('scalars',)


def get_region(instance, region):
    if region is None:
        if not hasattr(instance, 'region_'):
            raise ValueError(
                "No default region found. Argument must be supplied.")
        region = getattr(instance, 'region_')
    return region


def check_data(data):
    """
    Check the data returned by predict.
    If the data is a single array, return it as a tuple with a single element.

    Examples
    --------

    >>> check_data([1, 2, 3])
    ([1, 2, 3],)
    >>> check_data(([1, 2], [3, 4]))
    ([1, 2], [3, 4])
    """
    if not isinstance(data, tuple):
        data = (data,)
    return data


class BaseGridder(BaseEstimator):
    """
    Base class for gridders.

    Requires the implementation of the ``predict(easting, northing)`` method.
    The data returned by it should be a 1d or 2d numpy array for scalar data or
    a tuple with 1d or 2d numpy arrays for each component of vector data.

    Doesn't define any new attributes.

    This is a subclass of :class:`sklearn.base.BaseEstimator` and must abide by
    the same rules of the scikit-learn classes. Mainly:

    * ``__init__`` must **only** assign values to attributes based on the
      parameters it receives. All parameters must have default values.
      Parameter checking should be done in ``fit``.
    * Estimated parameters should be stored as attributes with names ending in
      ``_``.

    The child class can define the following attributes to control the names of
    coordinates and data values in the output ``xarray.Dataset``s and
    ``pandas.DataFrame``s and how distances are calculated:

    * ``coordinate_system``: either ``'cartesian'`` or ``'geographic'``. Will
      influence dimension names and distance calculations. Defaults to
      ``'cartesian'``.
    * ``data_type``: one of ``'scalar'``, ``'vector2d'``, or ``'vector3d'``.
      Defaults to ``'scalar'``.

    Examples
    --------

    >>> import numpy as np
    >>> class MeanGridder(BaseGridder):
    ...     "Gridder that always produces the mean of all data values"
    ...     def __init__(self, multiplier=1):
    ...         # Init should only assign the parameters to attributes
    ...         self.multiplier = multiplier
    ...     def fit(self, easting, northing, data):
    ...         # Argument checking should be done in fit
    ...         assert self.multiplier > 0
    ...         self.mean_ = data.mean()*self.multiplier
    ...         return self
    ...     def predict(self, easting, northing):
    ...         return np.ones_like(easting)*self.mean_


    """

    def grid(self, region=None, shape=(100, 100), dims=None, data_names=None):
        """
        """
        if dims is None:
            dims = get_dimensions(self)
        if data_names is None:
            data_names = get_data_names(self)
        region = get_region(self, region)
        easting, northing = grid_coordinates(region, shape)
        data = check_data(self.predict(easting, northing))
        east_lines = easting[0, :]
        north_lines = northing[:, 0]
        coords = {dims[0]: north_lines, dims[1]:east_lines}
        attrs = {'Generated by': repr(self)}
        data_vars = {}
        for data_array, data_name in zip(data, data_names):
            data_vars[data_name] = (dims, data_array, attrs)
        datagrid = xr.Dataset(data_vars, coords=coords, attrs=attrs)
        return datagrid

    def scatter(self, region=None, size=300, random_state=None, dims=None,
                data_names=None):
        """
        """
        if dims is None:
            dims = get_dimensions(self)
        if data_names is None:
            data_names = get_data_names(self)
        region = get_region(self, region)
        east, north = scatter_points(region, size, random_state)
        data = check_data(self.predict(east, north))
        column_names = [dim for dim in dims]
        column_names.extend(data_names)
        columns = [north, east]
        columns.extend(data)
        table = pd.DataFrame(
            {name: value for name, value in zip(column_names, columns)})
        return table

    def profile(self, point1, point2, size, dims=None, data_names=None):
        """
        """
        coordsys = getattr(self, 'coordinate_system', 'cartesian')
        if dims is None:
            dims = get_dimensions(self)
        if data_names is None:
            data_names = get_data_names(self)
        east, north, distances = profile_coordinates(
            point1, point2, size, coordinate_system=coordsys)
        data = check_data(self.predict(easting, northing))
        column_names = [dim for dim in dims]
        column_names.append('distance')
        column_names.extend(data_names)
        columns = [north, east, distances]
        columns.extend(data)
        table = pd.DataFrame(
            {name: value for name, value in zip(column_names, columns)})
        return table
