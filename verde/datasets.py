"""
Functions for loading test data and generating synthetic datasets.
"""
import numpy as np
import pandas as pd
import xarray as xr

from . import scatter_points, grid_coordinates


def make_synthetic_checkerboard(scatter=True, random_state=None):
    """
    Generate synthetic data in a checkerboard pattern.

    The mathematical model is:

    .. math::

        f(e, n) = a \sin(w_e e^2) \cos(w_n n^2)

    in which e is the easting coordinate and n is the northing coordinate.

    The model will evaluated on random points or on a regular grid depending on
    the value of *scatter*.

    Parameters
    ----------
    scatter : bool
        If ``True``, will evaluate the model on random points. Otherwise, will
        evaluate on a regular grid.
    random_state : numpy.random.RandomState or an int seed
        A random number generator used to define the state of the random
        permutations. Use a fixes seed to make sure computations are
        reproducible. Ignored if ``scatter=False``.

    Returns
    -------
    data : xarray.Dataset or pandas.DataFrame
        Will be a DataFrame of the points are random, a Dataset otherwise.

    """
    region = (0, 3000, -5150, -3800)
    size = 300
    shape = (50, 50)
    w_east, w_north = 1e-6, 1e-6
    amplitude = 4000
    if scatter:
        east, north = scatter_points(region, size, random_state=random_state)
        data = _checkerboard(east, north, amplitude, w_east, w_north)
        return pd.DataFrame(dict(easting=east, northing=north, scalar=data))
    else:
        east, north = grid_coordinates(region, shape)
        data = _checkerboard(east, north, amplitude, w_east, w_north)
        dims = ['northing', 'easting']
        coords = dict(easting=east[0, :], northing=north[:, 0])
        return xr.Dataset(dict(scalar=(dims, data)), coords=coords,
                          attrs={'Generated by', 'verde.check


def _checkerboard(easting, northing, amplitude, w_east, w_north):
    """
    A checkerboard function.
    """
    return amplitude*np.sin(w_east*easting**2)*np.cos(w_north*northing**2)


