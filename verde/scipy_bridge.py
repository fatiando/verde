"""
A gridder that uses scipy.interpolate as the backend.
"""
import numpy as np
import xarray as xr
from scipy.interpolate import LinearNDInterpolator, NearestNDInterpolator, \
    CloughTocher2DInterpolator

from . import grid_coordinates


class ScipyGridder():
    """
    Gridding using scipy.interpolate as the backend.
    """

    _classes = {
        'linear': LinearNDInterpolator,
        'nearest': NearestNDInterpolator,
        'cubic': CloughTocher2DInterpolator,
    }

    def __init__(self, method='linear', **kwargs):
        self.method = method
        self.kwargs = kwargs
        self._interpolator = None

    def __repr__(self):
        args = dict(method=self.method)
        args.update(self.kwargs)
        arg_str = ', '.join(['{}={}'.format(arg, repr(value))
                             for arg, value in args.items()])
        rep = '{}({})'.format(self.__class__.__name__, arg_str)
        return rep

    def fit(self, easting, northing, data):
        points = np.column_stack((easting.ravel(), northing.ravel()))
        self._interpolator = self._classes[self.method](points, data.ravel(),
                                                        **self.kwargs)
        return self

    def predict(self, easting, northing):
        points = (easting, northing)
        data = self._interpolator(points)
        return data

    def grid(self, region, shape):
        easting, northing = grid_coordinates(region, shape)
        data = self.predict(easting, northing)
        east_lines = easting[0, :]
        north_lines = northing[:, 0]
        coords = dict(northing=north_lines, easting=east_lines)
        dims = ['northing', 'easting']
        attrs = {'Generated by': repr(self)}
        datagrid = xr.DataArray(data, coords=coords, dims=dims, attrs=attrs)
        return datagrid

    def profile(self, begin, end, size):
        east1, north1 = begin
        east2, north2 = end
        separation = np.sqrt((east1 - east2)**2 + (north1 - north2)**2)
        distances = np.linspace(0, separation, size)
        angle = np.arctan2(north2 - north1, east2 - east1)
        easting = east1 + distances*np.cos(angle)
        northing = north1 + distances*np.sin(angle)
        data = self.predict(easting, northing)
        return distances, data
